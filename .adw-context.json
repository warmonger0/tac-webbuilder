{
  "adw_id": "d683d74a",
  "worktree_path": "/Users/Warmonger0/tac/tac-webbuilder/trees/d683d74a",
  "created_at": "2025-12-22T15:15:48.132688",
  "changed_files": [
    ".adw-context.json",
    ".mcp.json"
  ],
  "target_files": [
    "adws/adw_modules/data_types.py",
    "adws/adw_modules/state.py",
    "adws/tests/test_data_types.py"
  ],
  "preloaded_content": {
    "adws/adw_modules/data_types.py": "\"\"\"Data types for GitHub API responses and Claude Code agent.\"\"\"\n\nfrom datetime import datetime\nfrom typing import Optional, List, Literal\nfrom pydantic import BaseModel, Field\nfrom enum import Enum\n\n\n# Retry codes for Claude Code execution errors\nclass RetryCode(str, Enum):\n    \"\"\"Codes indicating different types of errors that may be retryable.\"\"\"\n\n    CLAUDE_CODE_ERROR = \"claude_code_error\"  # General Claude Code CLI error\n    TIMEOUT_ERROR = \"timeout_error\"  # Command timed out\n    EXECUTION_ERROR = \"execution_error\"  # Error during execution\n    ERROR_DURING_EXECUTION = \"error_during_execution\"  # Agent encountered an error\n    NONE = \"none\"  # No retry needed\n\n\n# Supported slash commands for issue classification\n# These should align with your custom slash commands in .claude/commands that you want to run\nIssueClassSlashCommand = Literal[\"/chore\", \"/bug\", \"/feature\", \"/patch\"]\n\n# Model set types for ADW workflows\n# lightweight = Haiku (cheap, fast), base = Sonnet (smart), heavy = Opus (most capable)\nModelSet = Literal[\"base\", \"heavy\", \"lightweight\"]\n\n# ADW workflow types (all isolated now)\nADWWorkflow = Literal[\n    \"adw_plan_iso\",  # Planning only\n    \"adw_patch_iso\",  # Direct patch from issue\n    \"adw_build_iso\",  # Building only (dependent workflow)\n    \"adw_test_iso\",  # Testing only (dependent workflow)\n    \"adw_review_iso\",  # Review only (dependent workflow)\n    \"adw_document_iso\",  # Documentation only (dependent workflow)\n    \"adw_ship_iso\",  # Ship/deployment workflow\n    \"adw_sdlc_ZTE_iso\",  # Zero Touch Execution - full SDLC with auto-merge\n    \"adw_plan_build_iso\",  # Plan + Build\n    \"adw_plan_build_test_iso\",  # Plan + Build + Test\n    \"adw_plan_build_test_review_iso\",  # Plan + Build + Test + Review\n    \"adw_plan_build_document_iso\",  # Plan + Build + Document\n    \"adw_plan_build_review_iso\",  # Plan + Build + Review\n    \"adw_sdlc_iso\",  # Complete SDLC: Plan + Build + Test + Review + Document\n]\n\n# All slash commands used in the ADW system\n# Includes issue classification commands and ADW-specific commands\nSlashCommand = Literal[\n    # Issue classification commands\n    \"/chore\",\n    \"/bug\",\n    \"/feature\",\n    # ADW workflow commands\n    \"/classify_issue\",\n    \"/classify_adw\",\n    \"/generate_branch_name\",\n    \"/commit\",\n    \"/pull_request\",\n    \"/implement\",\n    \"/test\",\n    \"/resolve_failed_test\",\n    \"/test_e2e\",\n    \"/resolve_failed_e2e_test\",\n    \"/review\",\n    \"/patch\",\n    \"/document\",\n    \"/track_agentic_kpis\",\n    # Installation/setup commands\n    \"/install_worktree\",\n]\n\n\nclass GitHubUser(BaseModel):\n    \"\"\"GitHub user model.\"\"\"\n\n    id: Optional[str] = None  # Not always returned by GitHub API\n    login: str\n    name: Optional[str] = None\n    is_bot: bool = Field(default=False, alias=\"is_bot\")\n\n\nclass GitHubLabel(BaseModel):\n    \"\"\"GitHub label model.\"\"\"\n\n    id: str\n    name: str\n    color: str\n    description: Optional[str] = None\n\n\nclass GitHubMilestone(BaseModel):\n    \"\"\"GitHub milestone model.\"\"\"\n\n    id: str\n    number: int\n    title: str\n    description: Optional[str] = None\n    state: str\n\n\nclass GitHubComment(BaseModel):\n    \"\"\"GitHub comment model.\"\"\"\n\n    id: str\n    author: GitHubUser\n    body: str\n    created_at: datetime = Field(alias=\"createdAt\")\n    updated_at: Optional[datetime] = Field(\n        None, alias=\"updatedAt\"\n    )  # Not always returned\n\n\nclass GitHubIssueListItem(BaseModel):\n    \"\"\"GitHub issue model for list responses (simplified).\"\"\"\n\n    number: int\n    title: str\n    body: str\n    labels: List[GitHubLabel] = []\n    created_at: datetime = Field(alias=\"createdAt\")\n    updated_at: datetime = Field(alias=\"updatedAt\")\n\n    class Config:\n        populate_by_name = True\n\n\nclass GitHubIssue(BaseModel):\n    \"\"\"GitHub issue model.\"\"\"\n\n    number: int\n    title: str\n    body: str\n    state: str\n    author: GitHubUser\n    assignees: List[GitHubUser] = []\n    labels: List[GitHubLabel] = []\n    milestone: Optional[GitHubMilestone] = None\n    comments: List[GitHubComment] = []\n    created_at: datetime = Field(alias=\"createdAt\")\n    updated_at: datetime = Field(alias=\"updatedAt\")\n    closed_at: Optional[datetime] = Field(None, alias=\"closedAt\")\n    url: str\n\n    class Config:\n        populate_by_name = True\n\n\nclass AgentPromptRequest(BaseModel):\n    \"\"\"Claude Code agent prompt configuration.\"\"\"\n\n    prompt: str\n    adw_id: str\n    agent_name: str = \"ops\"\n    model: Literal[\"sonnet\", \"opus\"] = \"sonnet\"\n    dangerously_skip_permissions: bool = False\n    output_file: str\n    working_dir: Optional[str] = None\n\n\nclass AgentPromptResponse(BaseModel):\n    \"\"\"Claude Code agent response.\"\"\"\n\n    output: str\n    success: bool\n    session_id: Optional[str] = None\n    retry_code: RetryCode = RetryCode.NONE\n\n\nclass AgentTemplateRequest(BaseModel):\n    \"\"\"Claude Code agent template execution request.\"\"\"\n\n    agent_name: str\n    slash_command: SlashCommand\n    args: List[str]\n    adw_id: str\n    model: Literal[\"sonnet\", \"opus\"] = \"sonnet\"\n    working_dir: Optional[str] = None\n\n\nclass ClaudeCodeResultMessage(BaseModel):\n    \"\"\"Claude Code JSONL result message (last line).\"\"\"\n\n    type: str\n    subtype: str\n    is_error: bool\n    duration_ms: int\n    duration_api_ms: int\n    num_turns: int\n    result: str\n    session_id: str\n    total_cost_usd: float\n\n\nclass TestResult(BaseModel):\n    \"\"\"Individual test result from test suite execution.\"\"\"\n\n    test_name: str\n    passed: bool\n    execution_command: str\n    test_purpose: str\n    error: Optional[str] = None\n\n\nclass E2ETestResult(BaseModel):\n    \"\"\"Individual E2E test result from browser automation.\"\"\"\n\n    test_name: str\n    status: Literal[\"passed\", \"failed\"]\n    test_path: str  # Path to the test file for re-execution\n    screenshots: List[str] = []\n    error: Optional[str] = None\n\n    @property\n    def passed(self) -> bool:\n        \"\"\"Check if test passed.\"\"\"\n        return self.status == \"passed\"\n\n\nclass ADWStateData(BaseModel):\n    \"\"\"Minimal persistent state for ADW workflow.\n\n    Stored in agents/{adw_id}/adw_state.json\n    Contains ONLY execution metadata (paths, ports, outputs).\n\n    IMPORTANT: Coordination state (status, current_phase) is stored in the database\n    (phase_queue table). This file is NOT the source of truth for workflow status.\n    See docs/adw/state-management-ssot.md for complete SSoT rules.\n    \"\"\"\n\n    adw_id: str\n    issue_number: Optional[str] = None\n    branch_name: Optional[str] = None\n    plan_file: Optional[str] = None\n    issue_class: Optional[IssueClassSlashCommand] = None\n    worktree_path: Optional[str] = None\n    backend_port: Optional[int] = None\n    frontend_port: Optional[int] = None\n    model_set: Optional[ModelSet] = \"base\"  # Default to \"base\" model set\n    all_adws: List[str] = Field(default_factory=list)\n\n    # Cost tracking fields\n    estimated_cost_total: Optional[float] = None\n    estimated_cost_breakdown: Optional[dict] = None  # Per-phase estimates\n\n    # Workflow context metadata (NOT coordination state)\n    workflow_template: Optional[str] = None  # e.g., \"adw_sdlc_complete_zte_iso\"\n    model_used: Optional[str] = None  # e.g., \"sonnet\", \"haiku\", \"opus\"\n    start_time: Optional[str] = None  # ISO format timestamp\n    nl_input: Optional[str] = None  # Natural language input from user\n    github_url: Optional[str] = None  # GitHub issue URL\n\n    # NOTE: 'status' and 'current_phase' removed - Database is SSoT for coordination\n    # Use PhaseQueueRepository to read/write workflow status and current phase\n\n\nclass ReviewIssue(BaseModel):\n    \"\"\"Individual review issue found during spec verification.\"\"\"\n\n    review_issue_number: int\n    screenshot_path: str  # Local file path to screenshot (e.g., \"agents/ADW-123/reviewer/review_img/error.png\")\n    screenshot_url: Optional[str] = (\n        None  # Public URL after upload (e.g., \"https://domain.com/adw/ADW-123/review/error.png\")\n    )\n    issue_description: str\n    issue_resolution: str\n    issue_severity: Literal[\"skippable\", \"tech_debt\", \"blocker\"]\n\n\nclass ReviewResult(BaseModel):\n    \"\"\"Result from reviewing implementation against specification.\"\"\"\n\n    success: bool\n    review_summary: (\n        str  # 2-4 sentences describing what was built and whether it matches the spec\n    )\n    review_issues: List[ReviewIssue] = []\n    screenshots: List[str] = (\n        []\n    )  # Local file paths (e.g., [\"agents/ADW-123/reviewer/review_img/ui.png\"])\n    screenshot_urls: List[str] = (\n        []\n    )  # Public URLs after upload, indexed-aligned with screenshots\n\n\nclass DocumentationResult(BaseModel):\n    \"\"\"Result from documentation generation workflow.\"\"\"\n\n    success: bool\n    documentation_created: bool\n    documentation_path: Optional[str] = None\n    error_message: Optional[str] = None\n\n\nclass ADWExtractionResult(BaseModel):\n    \"\"\"Result from extracting ADW information from text.\"\"\"\n    \n    workflow_command: Optional[str] = None  # e.g., \"adw_plan_iso\" (without slash)\n    adw_id: Optional[str] = None  # 8-character ADW ID\n    model_set: Optional[ModelSet] = \"base\"  # Model set to use, defaults to \"base\"\n    \n    @property\n    def has_workflow(self) -> bool:\n        \"\"\"Check if a workflow command was extracted.\"\"\"\n        return self.workflow_command is not None\n",
    "adws/adw_modules/state.py": "\"\"\"State management for ADW composable architecture.\n\nProvides persistent state management via file storage and\ntransient state passing between scripts via stdin/stdout.\n\"\"\"\n\nimport json\nimport os\nimport sys\nimport logging\nfrom typing import Dict, Any, Optional\nfrom adw_modules.data_types import ADWStateData\n\n\nclass ADWState:\n    \"\"\"Container for ADW workflow state with file persistence.\"\"\"\n\n    STATE_FILENAME = \"adw_state.json\"\n\n    def __init__(self, adw_id: str):\n        \"\"\"Initialize ADWState with a required ADW ID.\n        \n        Args:\n            adw_id: The ADW ID for this state (required)\n        \"\"\"\n        if not adw_id:\n            raise ValueError(\"adw_id is required for ADWState\")\n        \n        self.adw_id = adw_id\n        # Start with minimal state\n        self.data: Dict[str, Any] = {\"adw_id\": self.adw_id}\n        self.logger = logging.getLogger(__name__)\n\n    def update(self, **kwargs):\n        \"\"\"Update state with new key-value pairs.\n\n        IMPORTANT: Does NOT accept 'status' or 'current_phase' - these are coordination\n        state fields that belong in the database. Use PhaseQueueRepository for those.\n        See docs/adw/state-management-ssot.md for complete SSoT rules.\n        \"\"\"\n        # Core execution metadata fields (NOT coordination state)\n        core_fields = {\n            \"adw_id\", \"issue_number\", \"branch_name\", \"plan_file\", \"issue_class\",\n            \"worktree_path\", \"backend_port\", \"frontend_port\", \"model_set\", \"all_adws\",\n            \"estimated_cost_total\", \"estimated_cost_breakdown\",\n            # Workflow context metadata\n            \"workflow_template\", \"model_used\", \"start_time\", \"end_time\", \"nl_input\", \"github_url\",\n            # Phase output metadata\n            \"baseline_errors\", \"external_build_results\", \"external_lint_results\",\n            \"external_test_results\", \"review_results\", \"integration_checklist\",\n            \"integration_checklist_markdown\"\n        }\n\n        # Validate no forbidden fields (SSoT enforcement)\n        forbidden_fields = {\"status\", \"current_phase\"}\n        for key in kwargs:\n            if key in forbidden_fields:\n                raise ValueError(\n                    f\"Cannot update '{key}' in state file. Database is SSoT for coordination state. \"\n                    f\"Use PhaseQueueRepository.update_status() instead. \"\n                    f\"See docs/adw/state-management-ssot.md\"\n                )\n\n        for key, value in kwargs.items():\n            if key in core_fields:\n                self.data[key] = value\n\n    def get(self, key: str, default=None):\n        \"\"\"Get value from state by key.\"\"\"\n        return self.data.get(key, default)\n\n    def append_adw_id(self, adw_id: str):\n        \"\"\"Append an ADW ID to the all_adws list if not already present.\"\"\"\n        all_adws = self.data.get(\"all_adws\", [])\n        if adw_id not in all_adws:\n            all_adws.append(adw_id)\n            self.data[\"all_adws\"] = all_adws\n\n    def get_working_directory(self) -> str:\n        \"\"\"Get the working directory for this ADW instance.\n        \n        Returns worktree_path if set (for isolated workflows),\n        otherwise returns the main repo path.\n        \"\"\"\n        worktree_path = self.data.get(\"worktree_path\")\n        if worktree_path:\n            return worktree_path\n        \n        # Return main repo path (parent of adws directory)\n        return os.path.dirname(\n            os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n        )\n\n    def get_state_path(self) -> str:\n        \"\"\"Get path to state file.\"\"\"\n        project_root = os.path.dirname(\n            os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n        )\n        return os.path.join(project_root, \"agents\", self.adw_id, self.STATE_FILENAME)\n\n    def save(self, workflow_step: Optional[str] = None) -> None:\n        \"\"\"Save state to file in agents/{adw_id}/adw_state.json.\n\n        IMPORTANT: Does NOT save 'status' or 'current_phase' - these belong in database.\n        See docs/adw/state-management-ssot.md for complete SSoT rules.\n        \"\"\"\n        state_path = self.get_state_path()\n        os.makedirs(os.path.dirname(state_path), exist_ok=True)\n\n        # Validate no forbidden fields before saving (SSoT enforcement)\n        forbidden_fields = {\"status\", \"current_phase\"}\n        found_forbidden = [f for f in forbidden_fields if f in self.data]\n        if found_forbidden:\n            raise ValueError(\n                f\"Cannot save state with forbidden fields: {found_forbidden}. \"\n                f\"These are coordination state fields that belong in database. \"\n                f\"Use PhaseQueueRepository for status/current_phase. \"\n                f\"See docs/adw/state-management-ssot.md\"\n            )\n\n        # Create ADWStateData for validation of core execution metadata fields\n        state_data = ADWStateData(\n            adw_id=self.data.get(\"adw_id\"),\n            issue_number=self.data.get(\"issue_number\"),\n            branch_name=self.data.get(\"branch_name\"),\n            plan_file=self.data.get(\"plan_file\"),\n            issue_class=self.data.get(\"issue_class\"),\n            worktree_path=self.data.get(\"worktree_path\"),\n            backend_port=self.data.get(\"backend_port\"),\n            frontend_port=self.data.get(\"frontend_port\"),\n            model_set=self.data.get(\"model_set\", \"base\"),\n            all_adws=self.data.get(\"all_adws\", []),\n            estimated_cost_total=self.data.get(\"estimated_cost_total\"),\n            estimated_cost_breakdown=self.data.get(\"estimated_cost_breakdown\"),\n            # Workflow context metadata (NOT coordination state)\n            workflow_template=self.data.get(\"workflow_template\"),\n            model_used=self.data.get(\"model_used\"),\n            start_time=self.data.get(\"start_time\"),\n            nl_input=self.data.get(\"nl_input\"),\n            github_url=self.data.get(\"github_url\"),\n        )\n\n        # Start with validated core fields\n        save_data = state_data.model_dump()\n\n        # Add extra fields (like external_build_results, external_test_results, etc.)\n        core_field_names = set(state_data.model_fields.keys())\n        for key, value in self.data.items():\n            if key not in core_field_names:\n                # Double-check no forbidden fields slip through\n                if key in forbidden_fields:\n                    continue  # Skip forbidden fields silently\n                save_data[key] = value\n\n        # Save as JSON\n        with open(state_path, \"w\") as f:\n            json.dump(save_data, f, indent=2)\n\n        self.logger.info(f\"Saved state to {state_path}\")\n        if workflow_step:\n            self.logger.info(f\"State updated by: {workflow_step}\")\n\n    @classmethod\n    def load(\n        cls, adw_id: str, logger: Optional[logging.Logger] = None\n    ) -> Optional[\"ADWState\"]:\n        \"\"\"Load state from file if it exists.\"\"\"\n        project_root = os.path.dirname(\n            os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n        )\n        state_path = os.path.join(project_root, \"agents\", adw_id, cls.STATE_FILENAME)\n\n        if not os.path.exists(state_path):\n            return None\n\n        try:\n            with open(state_path, \"r\") as f:\n                data = json.load(f)\n\n            # Validate core fields with ADWStateData\n            # This will raise an error if core fields are invalid\n            state_data = ADWStateData(**{k: v for k, v in data.items() if k in ADWStateData.model_fields})\n\n            # Create ADWState instance\n            state = cls(state_data.adw_id)\n            # Use full data to preserve extra fields (like external_build_results)\n            state.data = data\n\n            if logger:\n                logger.info(f\"\ud83d\udd0d Found existing state from {state_path}\")\n                logger.info(f\"State: {json.dumps(data, indent=2)}\")\n\n            return state\n        except Exception as e:\n            if logger:\n                logger.error(f\"Failed to load state from {state_path}: {e}\")\n            return None\n\n    @classmethod\n    def from_stdin(cls) -> Optional[\"ADWState\"]:\n        \"\"\"Read state from stdin if available (for piped input).\n\n        Returns None if no piped input is available (stdin is a tty).\n        \"\"\"\n        if sys.stdin.isatty():\n            return None\n        try:\n            input_data = sys.stdin.read()\n            if not input_data.strip():\n                return None\n            data = json.loads(input_data)\n            adw_id = data.get(\"adw_id\")\n            if not adw_id:\n                return None  # No valid state without adw_id\n            state = cls(adw_id)\n            state.data = data\n            return state\n        except (json.JSONDecodeError, EOFError):\n            return None\n\n    def to_stdout(self):\n        \"\"\"Write state to stdout as JSON (for piping to next script).\"\"\"\n        # Only output core fields\n        output_data = {\n            \"adw_id\": self.data.get(\"adw_id\"),\n            \"issue_number\": self.data.get(\"issue_number\"),\n            \"branch_name\": self.data.get(\"branch_name\"),\n            \"plan_file\": self.data.get(\"plan_file\"),\n            \"issue_class\": self.data.get(\"issue_class\"),\n            \"worktree_path\": self.data.get(\"worktree_path\"),\n            \"backend_port\": self.data.get(\"backend_port\"),\n            \"frontend_port\": self.data.get(\"frontend_port\"),\n            \"all_adws\": self.data.get(\"all_adws\", []),\n        }\n        print(json.dumps(output_data, indent=2))\n"
  }
}