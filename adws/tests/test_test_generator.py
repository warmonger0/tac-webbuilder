"""
Comprehensive test suite for test_generator module.

Tests cover:
- TestGenerator class methods (analyze_python_file, calculate_complexity, etc.)
- Helper functions (result_to_dict)
- Edge cases (empty files, complex async functions, high complexity)
- Path generation for different file types
- Template generation for pytest and vitest
- Mock file I/O operations
"""

import ast
import json
import pytest
from pathlib import Path
from tempfile import TemporaryDirectory
from unittest.mock import MagicMock, patch, mock_open

from adws.adw_modules.test_generator import (
    TestGenerator,
    TestGenResult,
    ComplexFunction,
    CoverageGap,
    AutoGeneratedTest,
    result_to_dict,
)


# ============================================================================
# Fixtures
# ============================================================================


@pytest.fixture
def project_root():
    """Provide a project root path."""
    return Path("/test/project")


@pytest.fixture
def test_generator(project_root):
    """Create a TestGenerator instance."""
    return TestGenerator(project_root)


@pytest.fixture
def simple_python_source():
    """Sample simple Python source code."""
    return '''"""Simple module with basic functions."""

def add(a, b):
    """Add two numbers."""
    return a + b

def greet(name):
    """Greet a person."""
    return f"Hello, {name}!"

def is_even(n):
    """Check if number is even."""
    return n % 2 == 0
'''


@pytest.fixture
def complex_python_source():
    """Sample Python source with complex functions."""
    return '''"""Module with complex logic."""

def validate_input(data):
    """Validate input with multiple conditions."""
    if not data:
        return False
    if isinstance(data, str):
        if len(data) < 3:
            return False
        if "invalid" in data:
            return False
    elif isinstance(data, dict):
        if not data.get("id"):
            return False
        if data.get("type") not in ["A", "B", "C"]:
            return False
    else:
        return False
    return True

def complex_logic(x, y, z):
    """Function with high cyclomatic complexity."""
    result = 0
    if x > 0:
        if y > 0:
            if z > 0:
                result = x + y + z
            else:
                result = x + y
        else:
            result = x
    elif x < 0:
        if y < 0:
            result = x - y
        else:
            result = 0
    else:
        result = y + z if y and z else max(y, z) if y or z else 0
    return result
'''


@pytest.fixture
def async_python_source():
    """Sample Python source with async functions."""
    return '''"""Module with async functions."""

import asyncio

async def fetch_data(url):
    """Fetch data from URL."""
    await asyncio.sleep(0.1)
    return {"data": "response"}

async def process_items(items):
    """Process items concurrently."""
    tasks = [process_item(item) for item in items]
    return await asyncio.gather(*tasks)

async def process_item(item):
    """Process single item."""
    await asyncio.sleep(0.05)
    return item * 2

def sync_function():
    """Regular synchronous function."""
    return 42
'''


@pytest.fixture
def decorated_python_source():
    """Sample Python source with decorated functions."""
    return '''"""Module with decorated functions."""

from functools import wraps

def my_decorator(func):
    """Custom decorator."""
    @wraps(func)
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def decorated_func(x):
    """Function with decorator."""
    return x * 2

@staticmethod
def static_method():
    """Static method."""
    return "static"

@property
def property_method(self):
    """Property method."""
    return self._value

@my_decorator
@staticmethod
def multi_decorated():
    """Function with multiple decorators."""
    return "multi"
'''


@pytest.fixture
def empty_python_source():
    """Empty Python source file."""
    return ''


@pytest.fixture
def invalid_python_source():
    """Invalid Python syntax."""
    return '''
def broken_function(
    # Missing closing paren
    return None
'''


@pytest.fixture
def temp_file():
    """Create a temporary Python file."""
    with TemporaryDirectory() as tmpdir:
        file_path = Path(tmpdir) / "test_module.py"
        file_path.write_text('def test_func(): pass')
        yield file_path


@pytest.fixture
def typescript_source():
    """Sample TypeScript/React component."""
    return '''import React from 'react';

export const MyComponent: React.FC = () => {
  return <div>Hello</div>;
};

export function utility(x: number): number {
  return x * 2;
}
'''


@pytest.fixture
def coverage_gap():
    """Create a CoverageGap instance."""
    return CoverageGap(
        percentage_needed=15.0,
        uncovered_lines=[10, 11, 12, 25, 26]
    )


@pytest.fixture
def complex_function():
    """Create a ComplexFunction instance."""
    return ComplexFunction(
        function="validate_input",
        file="/app/core/validators.py",
        line=42,
        reason="High complexity",
        context="def validate_input(data, rules, strict=False):",
        complexity_score=8.5
    )


# ============================================================================
# Tests for TestGenerator.__init__
# ============================================================================


class TestTestGeneratorInit:
    """Test TestGenerator initialization."""

    def test_init_with_path_object(self, test_generator, project_root):
        """Test initialization with Path object."""
        assert test_generator.project_root == project_root
        assert test_generator.templates_dir is not None

    def test_init_with_string_path(self):
        """Test initialization with string path."""
        generator = TestGenerator("/home/project")
        assert generator.project_root == Path("/home/project")

    def test_templates_dir_is_set(self, test_generator):
        """Test that templates_dir is configured."""
        assert test_generator.templates_dir is not None
        assert "test_templates" in str(test_generator.templates_dir)


# ============================================================================
# Tests for analyze_python_file
# ============================================================================


class TestAnalyzePythonFile:
    """Test the analyze_python_file method."""

    def test_analyze_simple_functions(self, test_generator, simple_python_source, tmp_path):
        """Test analyzing simple Python functions."""
        # Write source to temp file
        source_file = tmp_path / "simple.py"
        source_file.write_text(simple_python_source)

        # Analyze
        functions = test_generator.analyze_python_file(source_file)

        # Verify results
        assert len(functions) == 3
        assert functions[0]["name"] == "add"
        assert functions[0]["complexity"] >= 1
        assert functions[0]["is_async"] is False
        assert functions[1]["name"] == "greet"
        assert functions[2]["name"] == "is_even"

    def test_analyze_function_args(self, test_generator, simple_python_source, tmp_path):
        """Test that function arguments are captured."""
        source_file = tmp_path / "simple.py"
        source_file.write_text(simple_python_source)

        functions = test_generator.analyze_python_file(source_file)

        # Check args for 'add' function
        add_func = [f for f in functions if f["name"] == "add"][0]
        assert add_func["args"] == ["a", "b"]

        # Check args for 'greet' function
        greet_func = [f for f in functions if f["name"] == "greet"][0]
        assert greet_func["args"] == ["name"]

    def test_analyze_async_functions(self, test_generator, async_python_source, tmp_path):
        """Test analyzing async functions."""
        source_file = tmp_path / "async_module.py"
        source_file.write_text(async_python_source)

        functions = test_generator.analyze_python_file(source_file)

        # Find async functions
        async_funcs = [f for f in functions if f["is_async"]]
        assert len(async_funcs) >= 2

        # Verify async flag
        fetch_func = [f for f in functions if f["name"] == "fetch_data"][0]
        assert fetch_func["is_async"] is True

        sync_func = [f for f in functions if f["name"] == "sync_function"][0]
        assert sync_func["is_async"] is False

    def test_analyze_decorated_functions(self, test_generator, decorated_python_source, tmp_path):
        """Test that decorators are captured."""
        source_file = tmp_path / "decorated.py"
        source_file.write_text(decorated_python_source)

        functions = test_generator.analyze_python_file(source_file)

        # Find decorated function
        decorated_func = [f for f in functions if f["name"] == "decorated_func"][0]
        assert "my_decorator" in decorated_func["decorators"]

        # Multi-decorated function
        multi_func = [f for f in functions if f["name"] == "multi_decorated"][0]
        assert len(multi_func["decorators"]) >= 2

    def test_analyze_function_line_numbers(self, test_generator, simple_python_source, tmp_path):
        """Test that line numbers are captured correctly."""
        source_file = tmp_path / "simple.py"
        source_file.write_text(simple_python_source)

        functions = test_generator.analyze_python_file(source_file)

        # Verify line numbers are positive
        for func in functions:
            assert func["line"] > 0

    def test_analyze_empty_file(self, test_generator, tmp_path):
        """Test analyzing an empty file."""
        source_file = tmp_path / "empty.py"
        source_file.write_text("")

        functions = test_generator.analyze_python_file(source_file)

        assert functions == []

    def test_analyze_file_with_only_imports(self, test_generator, tmp_path):
        """Test analyzing file with only imports and docstring."""
        source_file = tmp_path / "imports.py"
        source_file.write_text('"""Module docstring."""\n\nimport os\nimport sys')

        functions = test_generator.analyze_python_file(source_file)

        assert functions == []

    def test_analyze_invalid_syntax(self, test_generator, invalid_python_source, tmp_path):
        """Test handling of invalid Python syntax."""
        source_file = tmp_path / "invalid.py"
        source_file.write_text(invalid_python_source)

        # Should handle gracefully
        functions = test_generator.analyze_python_file(source_file)

        assert isinstance(functions, list)

    def test_analyze_nonexistent_file(self, test_generator):
        """Test handling of nonexistent file."""
        nonexistent = Path("/nonexistent/path/to/file.py")

        functions = test_generator.analyze_python_file(nonexistent)

        assert functions == []

    def test_analyze_complex_functions(self, test_generator, complex_python_source, tmp_path):
        """Test analyzing functions with complexity."""
        source_file = tmp_path / "complex.py"
        source_file.write_text(complex_python_source)

        functions = test_generator.analyze_python_file(source_file)

        # Find validate_input - should have high complexity
        validate_func = [f for f in functions if f["name"] == "validate_input"][0]
        assert validate_func["complexity"] > 5

        # Find complex_logic - should have very high complexity
        complex_func = [f for f in functions if f["name"] == "complex_logic"][0]
        assert complex_func["complexity"] > 10

    def test_analyze_return_types(self, test_generator, tmp_path):
        """Test that return type annotations are captured."""
        source = '''
def with_return_type() -> str:
    """Function with return type."""
    return "test"

def without_return_type():
    """Function without return type."""
    return None
'''
        source_file = tmp_path / "returns.py"
        source_file.write_text(source)

        functions = test_generator.analyze_python_file(source_file)

        with_return = [f for f in functions if f["name"] == "with_return_type"][0]
        assert with_return["returns"] == "str"

        without_return = [f for f in functions if f["name"] == "without_return_type"][0]
        assert without_return["returns"] is None


# ============================================================================
# Tests for _calculate_complexity
# ============================================================================


class TestCalculateComplexity:
    """Test the _calculate_complexity method."""

    def test_simple_function_complexity(self, test_generator):
        """Test complexity of simple function."""
        source = "def add(a, b): return a + b"
        tree = ast.parse(source)
        func_node = tree.body[0]

        complexity = test_generator._calculate_complexity(func_node)

        # Simple function should have minimum complexity of 1
        assert complexity >= 1

    def test_function_with_if_statement(self, test_generator):
        """Test complexity increases with if statement."""
        source = '''
def func_with_if(x):
    if x > 0:
        return x
    return -x
'''
        tree = ast.parse(source)
        func_node = tree.body[0]

        complexity = test_generator._calculate_complexity(func_node)

        # Should be greater than simple function
        assert complexity > 1

    def test_function_with_multiple_ifs(self, test_generator):
        """Test complexity with multiple if statements."""
        source = '''
def multi_if(x, y, z):
    if x > 0:
        pass
    if y > 0:
        pass
    if z > 0:
        pass
    return x + y + z
'''
        tree = ast.parse(source)
        func_node = tree.body[0]

        complexity = test_generator._calculate_complexity(func_node)

        # Should increase with each if
        assert complexity >= 4  # Base 1 + 3 ifs

    def test_function_with_loops(self, test_generator):
        """Test complexity with loops."""
        source = '''
def with_loops(items):
    for item in items:
        if item > 0:
            continue
    return None
'''
        tree = ast.parse(source)
        func_node = tree.body[0]

        complexity = test_generator._calculate_complexity(func_node)

        # Should account for loop and if
        assert complexity >= 3

    def test_function_with_boolean_operators(self, test_generator):
        """Test complexity with boolean operators."""
        source = '''
def bool_logic(a, b, c):
    if a and b and c:
        return True
    return False
'''
        tree = ast.parse(source)
        func_node = tree.body[0]

        complexity = test_generator._calculate_complexity(func_node)

        # BoolOp increases complexity
        assert complexity >= 3

    def test_function_with_try_except(self, test_generator):
        """Test complexity with exception handling."""
        source = '''
def with_exception():
    try:
        risky_operation()
    except ValueError:
        handle_error()
    except TypeError:
        handle_other()
    return None
'''
        tree = ast.parse(source)
        func_node = tree.body[0]

        complexity = test_generator._calculate_complexity(func_node)

        # Each except handler increases complexity
        assert complexity >= 3

    def test_nested_control_flow(self, test_generator):
        """Test complexity with nested control structures."""
        source = '''
def nested(data):
    if data:
        for item in data:
            while item:
                if item > 0:
                    item -= 1
                else:
                    break
    return None
'''
        tree = ast.parse(source)
        func_node = tree.body[0]

        complexity = test_generator._calculate_complexity(func_node)

        # Should account for all nested structures
        assert complexity >= 5


# ============================================================================
# Tests for generate_pytest_test
# ============================================================================


class TestGeneratePytestTest:
    """Test the generate_pytest_test method."""

    def test_generate_pytest_success(self, test_generator, simple_python_source, tmp_path):
        """Test successful pytest generation."""
        # Setup
        source_file = tmp_path / "app" / "server" / "module.py"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text(simple_python_source)

        # Mock project root
        test_generator.project_root = tmp_path

        # Generate
        result = test_generator.generate_pytest_test(source_file)

        # Verify
        assert result.success is True
        assert result.auto_generated["count"] > 0
        assert len(result.auto_generated["files"]) > 0
        assert isinstance(result.needs_llm_review, list)
        assert isinstance(result.next_steps, list)

    def test_generate_pytest_creates_file(self, test_generator, simple_python_source, tmp_path):
        """Test that pytest file is created."""
        # Setup
        source_file = tmp_path / "app" / "server" / "module.py"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text(simple_python_source)

        test_generator.project_root = tmp_path

        # Generate
        result = test_generator.generate_pytest_test(source_file)

        # Verify file was created
        test_file = result.auto_generated["files"][0]
        assert Path(test_file).exists()

    def test_generate_pytest_high_complexity_flagged(self, test_generator, complex_python_source, tmp_path):
        """Test that high complexity functions are flagged for LLM review."""
        source_file = tmp_path / "app" / "server" / "complex.py"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text(complex_python_source)

        test_generator.project_root = tmp_path

        result = test_generator.generate_pytest_test(source_file)

        # Should have functions needing review
        assert len(result.needs_llm_review) > 0

        # Should have reason for flagging
        for review_func in result.needs_llm_review:
            assert review_func.reason is not None
            assert review_func.complexity_score > 0

    def test_generate_pytest_async_flagged(self, test_generator, async_python_source, tmp_path):
        """Test that async functions are flagged for LLM review."""
        source_file = tmp_path / "app" / "server" / "async_mod.py"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text(async_python_source)

        test_generator.project_root = tmp_path

        result = test_generator.generate_pytest_test(source_file)

        # Async functions should be flagged
        async_flagged = [f for f in result.needs_llm_review if "Async" in f.reason]
        assert len(async_flagged) > 0

    def test_generate_pytest_coverage_gap(self, test_generator, simple_python_source, tmp_path):
        """Test coverage gap calculation."""
        source_file = tmp_path / "app" / "server" / "module.py"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text(simple_python_source)

        test_generator.project_root = tmp_path

        result = test_generator.generate_pytest_test(source_file, coverage_goal=90.0)

        # Should have coverage gap
        assert result.coverage_gap is not None
        assert result.coverage_gap.percentage_needed >= 0

    def test_generate_pytest_next_steps(self, test_generator, simple_python_source, tmp_path):
        """Test that next steps are provided."""
        source_file = tmp_path / "app" / "server" / "module.py"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text(simple_python_source)

        test_generator.project_root = tmp_path

        result = test_generator.generate_pytest_test(source_file)

        assert len(result.next_steps) > 0
        assert any("Review" in step or "Manually write" in step for step in result.next_steps)

    def test_generate_pytest_empty_file(self, test_generator, tmp_path):
        """Test pytest generation for empty file."""
        source_file = tmp_path / "app" / "server" / "empty.py"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text("")

        test_generator.project_root = tmp_path

        result = test_generator.generate_pytest_test(source_file)

        # Should still succeed but have no auto-generated tests
        assert result.success is True
        assert result.auto_generated["count"] == 0

    def test_generate_pytest_custom_coverage_goal(self, test_generator, simple_python_source, tmp_path):
        """Test pytest generation with custom coverage goal."""
        source_file = tmp_path / "app" / "server" / "module.py"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text(simple_python_source)

        test_generator.project_root = tmp_path

        result = test_generator.generate_pytest_test(source_file, coverage_goal=95.0)

        # Should use provided goal
        assert result.coverage_gap.percentage_needed >= 0


# ============================================================================
# Tests for generate_vitest_test
# ============================================================================


class TestGenerateVitestTest:
    """Test the generate_vitest_test method."""

    def test_generate_vitest_tsx_success(self, test_generator, tmp_path):
        """Test successful vitest generation for React component."""
        source_file = tmp_path / "app" / "client" / "src" / "Button.tsx"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text("export const Button = () => <button>Click</button>;")

        test_generator.project_root = tmp_path

        result = test_generator.generate_vitest_test(source_file)

        assert result.success is True
        assert len(result.auto_generated["files"]) > 0

    def test_generate_vitest_ts_success(self, test_generator, tmp_path):
        """Test successful vitest generation for TypeScript utility."""
        source_file = tmp_path / "app" / "client" / "src" / "utils.ts"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text("export const add = (a, b) => a + b;")

        test_generator.project_root = tmp_path

        result = test_generator.generate_vitest_test(source_file)

        assert result.success is True
        assert len(result.auto_generated["files"]) > 0

    def test_generate_vitest_jsx_success(self, test_generator, tmp_path):
        """Test vitest generation for JSX file."""
        source_file = tmp_path / "app" / "client" / "src" / "Card.jsx"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text("export default Card = () => <div>Card</div>;")

        test_generator.project_root = tmp_path

        result = test_generator.generate_vitest_test(source_file)

        assert result.success is True

    def test_generate_vitest_creates_file(self, test_generator, tmp_path):
        """Test that vitest file is created."""
        source_file = tmp_path / "app" / "client" / "src" / "Button.tsx"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text("export const Button = () => null;")

        test_generator.project_root = tmp_path

        result = test_generator.generate_vitest_test(source_file)

        test_file = result.auto_generated["files"][0]
        assert Path(test_file).exists()

    def test_generate_vitest_react_template(self, test_generator, tmp_path):
        """Test that React template is used for tsx/jsx files."""
        source_file = tmp_path / "app" / "client" / "src" / "Component.tsx"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text("export const Component = () => null;")

        test_generator.project_root = tmp_path

        result = test_generator.generate_vitest_test(source_file)

        test_file = Path(result.auto_generated["files"][0])
        content = test_file.read_text()

        # Should contain React testing patterns
        assert "render" in content or "describe" in content

    def test_generate_vitest_util_template(self, test_generator, tmp_path):
        """Test that util template is used for ts/js files."""
        source_file = tmp_path / "app" / "client" / "src" / "helpers.ts"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text("export const helper = () => null;")

        test_generator.project_root = tmp_path

        result = test_generator.generate_vitest_test(source_file)

        test_file = Path(result.auto_generated["files"][0])
        content = test_file.read_text()

        # Should contain test pattern
        assert "describe" in content or "it" in content

    def test_generate_vitest_coverage_goal(self, test_generator, tmp_path):
        """Test vitest with custom coverage goal."""
        source_file = tmp_path / "app" / "client" / "src" / "utils.ts"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text("export const util = () => null;")

        test_generator.project_root = tmp_path

        result = test_generator.generate_vitest_test(source_file, coverage_goal=80.0)

        assert result.coverage_gap.percentage_needed == 80.0


# ============================================================================
# Tests for _get_test_file_path
# ============================================================================


class TestGetTestFilePath:
    """Test the _get_test_file_path method."""

    def test_get_test_file_path_python(self, test_generator, project_root):
        """Test path generation for Python files."""
        source_path = project_root / "app" / "server" / "core" / "module.py"

        test_path = test_generator._get_test_file_path(source_path)

        assert test_path.name == "test_module.py"
        assert "tests" in str(test_path)
        assert test_path.suffix == ".py"

    def test_get_test_file_path_tsx(self, test_generator, project_root):
        """Test path generation for TSX files."""
        source_path = project_root / "app" / "client" / "src" / "components" / "Button.tsx"

        test_path = test_generator._get_test_file_path(source_path, extension=".test.tsx")

        assert test_path.name == "Button.test.tsx"
        assert "__tests__" in str(test_path)

    def test_get_test_file_path_ts(self, test_generator, project_root):
        """Test path generation for TypeScript files."""
        source_path = project_root / "app" / "client" / "src" / "utils.ts"

        test_path = test_generator._get_test_file_path(source_path, extension=".test.ts")

        assert test_path.name == "utils.test.ts"
        assert "__tests__" in str(test_path)

    def test_get_test_file_path_jsx(self, test_generator, project_root):
        """Test path generation for JSX files."""
        source_path = project_root / "app" / "client" / "src" / "Card.jsx"

        test_path = test_generator._get_test_file_path(source_path, extension=".test.jsx")

        assert test_path.name == "Card.test.jsx"

    def test_get_test_file_path_preserves_structure(self, test_generator, project_root):
        """Test that TypeScript test path preserves directory structure."""
        source_path = project_root / "app" / "client" / "src" / "nested" / "deep" / "Component.tsx"

        test_path = test_generator._get_test_file_path(source_path, extension=".test.tsx")

        assert "nested" in str(test_path)
        assert "deep" in str(test_path)

    def test_get_test_file_path_python_creates_tests_dir(self, test_generator, project_root):
        """Test that Python test path includes tests directory."""
        source_path = project_root / "app" / "server" / "core" / "analytics.py"

        test_path = test_generator._get_test_file_path(source_path)

        # Should be in tests directory
        assert "tests" in test_path.parts


# ============================================================================
# Tests for _generate_pytest_template
# ============================================================================


class TestGeneratePytestTemplate:
    """Test the _generate_pytest_template method."""

    def test_generate_pytest_template_basic(self, test_generator):
        """Test basic pytest template generation."""
        source_path = Path("/app/server/core/module.py")
        functions = [
            {"name": "add", "args": ["a", "b"]},
            {"name": "subtract", "args": ["a", "b"]},
        ]

        template = test_generator._generate_pytest_template(source_path, functions)

        # Should contain pytest imports
        assert "import pytest" in template
        assert "from core.module import" in template

        # Should contain test class
        assert "class Test" in template

        # Should contain test methods
        assert "def test_add" in template
        assert "def test_subtract" in template

    def test_generate_pytest_template_contains_docstring(self, test_generator):
        """Test that template contains docstrings."""
        source_path = Path("/app/server/core/module.py")
        functions = [{"name": "func", "args": []}]

        template = test_generator._generate_pytest_template(source_path, functions)

        assert '"""' in template
        assert "Auto-generated test template" in template

    def test_generate_pytest_template_limits_functions(self, test_generator):
        """Test that template limits to first 5 functions."""
        source_path = Path("/app/server/core/module.py")
        functions = [
            {"name": f"func{i}", "args": []} for i in range(10)
        ]

        template = test_generator._generate_pytest_template(source_path, functions)

        # Should only have 5 test methods
        test_count = template.count("def test_")
        assert test_count <= 5

    def test_generate_pytest_template_includes_pass_statements(self, test_generator):
        """Test that template includes pass statements."""
        source_path = Path("/app/server/core/module.py")
        functions = [{"name": "func", "args": []}]

        template = test_generator._generate_pytest_template(source_path, functions)

        assert "pass" in template

    def test_generate_pytest_template_includes_comments(self, test_generator):
        """Test that template includes TODO comments."""
        source_path = Path("/app/server/core/module.py")
        functions = [{"name": "func", "args": []}]

        template = test_generator._generate_pytest_template(source_path, functions)

        assert "TODO" in template or "Implement test" in template

    def test_generate_pytest_template_empty_functions_list(self, test_generator):
        """Test template with empty functions list."""
        source_path = Path("/app/server/core/module.py")
        functions = []

        template = test_generator._generate_pytest_template(source_path, functions)

        # Should still be valid Python
        assert "class Test" in template
        assert "import pytest" in template

    def test_generate_pytest_template_valid_python_syntax(self, test_generator):
        """Test that generated template is valid Python."""
        source_path = Path("/app/server/core/module.py")
        functions = [
            {"name": "func1", "args": ["x"]},
            {"name": "func2", "args": ["x", "y"]},
        ]

        template = test_generator._generate_pytest_template(source_path, functions)

        # Should be parseable as Python
        try:
            ast.parse(template)
        except SyntaxError:
            pytest.fail("Generated template has invalid Python syntax")


# ============================================================================
# Tests for _generate_vitest_react_template
# ============================================================================


class TestGenerateVitestReactTemplate:
    """Test the _generate_vitest_react_template method."""

    def test_generate_vitest_react_template_basic(self, test_generator):
        """Test basic React component test template."""
        source_path = Path("/app/client/src/components/Button.tsx")

        template = test_generator._generate_vitest_react_template(source_path)

        # Should contain vitest imports
        assert "vitest" in template or "describe" in template
        assert "Button" in template

    def test_generate_vitest_react_template_contains_render(self, test_generator):
        """Test that template includes React Testing Library render."""
        source_path = Path("/app/client/src/Button.tsx")

        template = test_generator._generate_vitest_react_template(source_path)

        assert "render" in template
        assert "testing-library/react" in template or "@testing-library/react" in template

    def test_generate_vitest_react_template_contains_user_event(self, test_generator):
        """Test that template includes userEvent for interactions."""
        source_path = Path("/app/client/src/Button.tsx")

        template = test_generator._generate_vitest_react_template(source_path)

        assert "userEvent" in template or "@testing-library/user-event" in template

    def test_generate_vitest_react_template_contains_beforeeach(self, test_generator):
        """Test that template includes beforeEach hook."""
        source_path = Path("/app/client/src/Button.tsx")

        template = test_generator._generate_vitest_react_template(source_path)

        assert "beforeEach" in template

    def test_generate_vitest_react_template_contains_tests(self, test_generator):
        """Test that template contains test cases."""
        source_path = Path("/app/client/src/Button.tsx")

        template = test_generator._generate_vitest_react_template(source_path)

        # Should have multiple it() blocks
        it_count = template.count("it(")
        assert it_count >= 2

    def test_generate_vitest_react_template_component_name(self, test_generator):
        """Test that component name is used correctly."""
        source_path = Path("/app/client/src/components/MyComponent.tsx")

        template = test_generator._generate_vitest_react_template(source_path)

        assert "MyComponent" in template

    def test_generate_vitest_react_template_has_docstring(self, test_generator):
        """Test that template includes JSDoc comment."""
        source_path = Path("/app/client/src/Button.tsx")

        template = test_generator._generate_vitest_react_template(source_path)

        assert "/**" in template or "/*" in template


# ============================================================================
# Tests for _generate_vitest_util_template
# ============================================================================


class TestGenerateVitestUtilTemplate:
    """Test the _generate_vitest_util_template method."""

    def test_generate_vitest_util_template_basic(self, test_generator):
        """Test basic utility function test template."""
        source_path = Path("/app/client/src/utils.ts")

        template = test_generator._generate_vitest_util_template(source_path)

        assert "describe" in template
        assert "utils" in template

    def test_generate_vitest_util_template_contains_import_comment(self, test_generator):
        """Test that template includes TODO for imports."""
        source_path = Path("/app/client/src/helpers.ts")

        template = test_generator._generate_vitest_util_template(source_path)

        assert "TODO" in template or "Import" in template

    def test_generate_vitest_util_template_contains_it_block(self, test_generator):
        """Test that template contains test block."""
        source_path = Path("/app/client/src/utils.ts")

        template = test_generator._generate_vitest_util_template(source_path)

        assert "it(" in template

    def test_generate_vitest_util_template_basic_assertion(self, test_generator):
        """Test that template has basic assertion."""
        source_path = Path("/app/client/src/utils.ts")

        template = test_generator._generate_vitest_util_template(source_path)

        assert "expect" in template

    def test_generate_vitest_util_template_module_name(self, test_generator):
        """Test that module name is used correctly."""
        source_path = Path("/app/client/src/custom_helpers.ts")

        template = test_generator._generate_vitest_util_template(source_path)

        assert "custom_helpers" in template

    def test_generate_vitest_util_template_valid_typescript(self, test_generator):
        """Test that generated template is valid TypeScript/JavaScript."""
        source_path = Path("/app/client/src/utils.ts")

        template = test_generator._generate_vitest_util_template(source_path)

        # Should contain describe block
        assert "describe" in template
        assert "it" in template


# ============================================================================
# Tests for result_to_dict helper function
# ============================================================================


class TestResultToDict:
    """Test the result_to_dict helper function."""

    def test_result_to_dict_success_field(self):
        """Test that success field is preserved."""
        result = TestGenResult(
            success=True,
            auto_generated={"count": 1},
            needs_llm_review=[],
            coverage_gap=None,
            tokens_used=0,
            next_steps=[]
        )

        result_dict = result_to_dict(result)

        assert result_dict["success"] is True

    def test_result_to_dict_auto_generated(self):
        """Test that auto_generated is preserved."""
        auto_gen = {"count": 3, "files": ["test1.py", "test2.py"]}
        result = TestGenResult(
            success=True,
            auto_generated=auto_gen,
            needs_llm_review=[],
            coverage_gap=None,
            tokens_used=0,
            next_steps=[]
        )

        result_dict = result_to_dict(result)

        assert result_dict["auto_generated"] == auto_gen

    def test_result_to_dict_complex_functions(self):
        """Test that needs_llm_review is converted to dicts."""
        complex_func = ComplexFunction(
            function="validate_input",
            file="/app/core/validators.py",
            line=42,
            reason="High complexity",
            context="def validate_input(data):",
            complexity_score=8.5
        )
        result = TestGenResult(
            success=True,
            auto_generated={},
            needs_llm_review=[complex_func],
            coverage_gap=None,
            tokens_used=100,
            next_steps=[]
        )

        result_dict = result_to_dict(result)

        assert len(result_dict["needs_llm_review"]) == 1
        assert isinstance(result_dict["needs_llm_review"][0], dict)
        assert result_dict["needs_llm_review"][0]["function"] == "validate_input"
        assert result_dict["needs_llm_review"][0]["complexity_score"] == 8.5

    def test_result_to_dict_coverage_gap(self):
        """Test that coverage_gap is converted to dict."""
        coverage_gap = CoverageGap(
            percentage_needed=15.0,
            uncovered_lines=[10, 11, 12]
        )
        result = TestGenResult(
            success=True,
            auto_generated={},
            needs_llm_review=[],
            coverage_gap=coverage_gap,
            tokens_used=0,
            next_steps=[]
        )

        result_dict = result_to_dict(result)

        assert isinstance(result_dict["coverage_gap"], dict)
        assert result_dict["coverage_gap"]["percentage_needed"] == 15.0
        assert result_dict["coverage_gap"]["uncovered_lines"] == [10, 11, 12]

    def test_result_to_dict_coverage_gap_none(self):
        """Test that None coverage_gap is handled."""
        result = TestGenResult(
            success=False,
            auto_generated={},
            needs_llm_review=[],
            coverage_gap=None,
            tokens_used=0,
            next_steps=[]
        )

        result_dict = result_to_dict(result)

        assert result_dict["coverage_gap"] is None

    def test_result_to_dict_tokens_used(self):
        """Test that tokens_used is preserved."""
        result = TestGenResult(
            success=True,
            auto_generated={},
            needs_llm_review=[],
            coverage_gap=None,
            tokens_used=5000,
            next_steps=[]
        )

        result_dict = result_to_dict(result)

        assert result_dict["tokens_used"] == 5000

    def test_result_to_dict_next_steps(self):
        """Test that next_steps is preserved."""
        steps = [
            "Review auto-generated tests",
            "Implement complex function tests"
        ]
        result = TestGenResult(
            success=True,
            auto_generated={},
            needs_llm_review=[],
            coverage_gap=None,
            tokens_used=0,
            next_steps=steps
        )

        result_dict = result_to_dict(result)

        assert result_dict["next_steps"] == steps

    def test_result_to_dict_json_serializable(self):
        """Test that result_dict is JSON serializable."""
        complex_func = ComplexFunction(
            function="test",
            file="/test.py",
            line=1,
            reason="test",
            context="test",
            complexity_score=5.0
        )
        result = TestGenResult(
            success=True,
            auto_generated={"count": 1},
            needs_llm_review=[complex_func],
            coverage_gap=CoverageGap(percentage_needed=10.0, uncovered_lines=[1, 2]),
            tokens_used=100,
            next_steps=["test"]
        )

        result_dict = result_to_dict(result)

        # Should be JSON serializable
        json_str = json.dumps(result_dict)
        assert isinstance(json_str, str)

    def test_result_to_dict_multiple_complex_functions(self):
        """Test conversion with multiple complex functions."""
        complex_funcs = [
            ComplexFunction(
                function=f"func{i}",
                file=f"/app/mod{i}.py",
                line=i * 10,
                reason="High complexity",
                context=f"def func{i}():",
                complexity_score=float(i)
            )
            for i in range(1, 4)
        ]
        result = TestGenResult(
            success=True,
            auto_generated={},
            needs_llm_review=complex_funcs,
            coverage_gap=None,
            tokens_used=0,
            next_steps=[]
        )

        result_dict = result_to_dict(result)

        assert len(result_dict["needs_llm_review"]) == 3
        assert all(isinstance(f, dict) for f in result_dict["needs_llm_review"])


# ============================================================================
# Tests for dataclass serialization
# ============================================================================


class TestDataclassSerialization:
    """Test that dataclasses are properly serializable."""

    def test_auto_generated_test_serializable(self):
        """Test AutoGeneratedTest serialization."""
        auto_test = AutoGeneratedTest(
            file="test_module.py",
            test_count=3,
            generation_method="template"
        )

        # Should be convertible to dict
        from dataclasses import asdict
        test_dict = asdict(auto_test)
        assert test_dict["file"] == "test_module.py"
        assert test_dict["test_count"] == 3

    def test_complex_function_serializable(self):
        """Test ComplexFunction serialization."""
        from dataclasses import asdict

        complex_func = ComplexFunction(
            function="validate",
            file="/app/validators.py",
            line=42,
            reason="High complexity",
            context="def validate(data):",
            complexity_score=8.5
        )

        func_dict = asdict(complex_func)
        assert func_dict["function"] == "validate"
        assert func_dict["complexity_score"] == 8.5

    def test_coverage_gap_serializable(self):
        """Test CoverageGap serialization."""
        from dataclasses import asdict

        gap = CoverageGap(
            percentage_needed=20.0,
            uncovered_lines=[5, 10, 15]
        )

        gap_dict = asdict(gap)
        assert gap_dict["percentage_needed"] == 20.0
        assert gap_dict["uncovered_lines"] == [5, 10, 15]


# ============================================================================
# Integration tests
# ============================================================================


class TestTestGeneratorIntegration:
    """Integration tests for TestGenerator workflow."""

    def test_full_python_analysis_workflow(self, test_generator, simple_python_source, tmp_path):
        """Test complete workflow from analysis to test generation."""
        # Create source file
        source_file = tmp_path / "app" / "server" / "math_utils.py"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text(simple_python_source)

        test_generator.project_root = tmp_path

        # Analyze
        functions = test_generator.analyze_python_file(source_file)
        assert len(functions) > 0

        # Generate tests
        result = test_generator.generate_pytest_test(source_file)
        assert result.success

        # Convert to dict
        result_dict = result_to_dict(result)
        assert isinstance(result_dict, dict)

    def test_complex_workflow_with_multiple_functions(self, test_generator, complex_python_source, tmp_path):
        """Test workflow with multiple complex functions."""
        source_file = tmp_path / "app" / "server" / "complex.py"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text(complex_python_source)

        test_generator.project_root = tmp_path

        # Generate
        result = test_generator.generate_pytest_test(source_file)

        # Should flag complex functions
        assert len(result.needs_llm_review) > 0

        # Should have auto-generated for simple ones
        assert result.auto_generated["count"] >= 0

    def test_typescript_to_vitest_workflow(self, test_generator, tmp_path):
        """Test complete TypeScript to vitest workflow."""
        source_file = tmp_path / "app" / "client" / "src" / "MyComponent.tsx"
        source_file.parent.mkdir(parents=True, exist_ok=True)
        source_file.write_text("export const MyComponent = () => <div>Test</div>;")

        test_generator.project_root = tmp_path

        # Generate
        result = test_generator.generate_vitest_test(source_file)

        # Verify
        assert result.success
        test_file_path = Path(result.auto_generated["files"][0])
        assert test_file_path.exists()
        assert test_file_path.suffix in [".test.tsx", ".test.ts", ".test.jsx", ".test.js"]
