# Test Generator Module - Comprehensive Test Suite

## Overview

This document describes the comprehensive pytest test suite for the `test_generator.py` module located at `adws/adw_modules/test_generator.py`.

The test suite provides complete coverage of:
- **TestGenerator class**: All public and private methods
- **Data structures**: Dataclass serialization and validation
- **Edge cases**: Empty files, invalid syntax, complex async functions
- **File type handling**: Python, TypeScript, TSX, JSX files
- **Template generation**: Both pytest and vitest templates
- **Integration workflows**: Full end-to-end test generation scenarios

## Test File Location

**File**: `/Users/Warmonger0/tac/tac-webbuilder/adws/tests/test_test_generator.py`

## Test Coverage

### Total Test Cases: 110+

The test suite is organized into the following sections:

#### 1. Fixture Definitions (10 fixtures)
- `project_root`: Mock project root path
- `test_generator`: TestGenerator instance
- `simple_python_source`: Sample simple Python code
- `complex_python_source`: Sample complex Python code
- `async_python_source`: Sample async Python functions
- `decorated_python_source`: Sample decorated functions
- `empty_python_source`: Empty Python file
- `invalid_python_source`: Invalid Python syntax
- `temp_file`: Temporary test file
- `typescript_source`: Sample TypeScript/React component
- `coverage_gap`: CoverageGap dataclass instance
- `complex_function`: ComplexFunction dataclass instance

#### 2. TestTestGeneratorInit (3 tests)
Tests for the `__init__` method:
- Initialization with Path object
- Initialization with string path
- Templates directory configuration

#### 3. TestAnalyzePythonFile (12 tests)
Tests for the `analyze_python_file` method:
- Analyzing simple functions and their arguments
- Async function detection
- Decorated function handling
- Line number tracking
- Empty file handling
- File with only imports
- Invalid syntax handling
- Nonexistent file handling
- Complex function detection
- Return type annotation capture

**Coverage**: Boundary conditions, edge cases, error handling

#### 4. TestCalculateComplexity (7 tests)
Tests for the `_calculate_complexity` method:
- Simple function baseline
- Functions with if statements
- Multiple conditional branches
- Loop structures
- Boolean operators
- Exception handling
- Nested control flow

**Coverage**: Cyclomatic complexity calculation, control flow detection

#### 5. TestGeneratePytestTest (8 tests)
Tests for the `generate_pytest_test` method:
- Successful pytest generation
- Test file creation
- High complexity function flagging
- Async function flagging
- Coverage gap calculation
- Next steps generation
- Empty file handling
- Custom coverage goals

**Coverage**: File creation, function categorization, result generation

#### 6. TestGenerateVitestTest (8 tests)
Tests for the `generate_vitest_test` method:
- TSX component test generation
- TypeScript utility test generation
- JSX file handling
- Test file creation
- React template usage
- Utility template usage
- Custom coverage goals

**Coverage**: Different file types, template selection

#### 7. TestGetTestFilePath (7 tests)
Tests for the `_get_test_file_path` method:
- Python file path generation
- TSX file path generation
- TypeScript file path generation
- JSX file path generation
- Directory structure preservation
- Tests directory inclusion

**Coverage**: Path mapping for different file types

#### 8. TestGeneratePytestTemplate (7 tests)
Tests for the `_generate_pytest_template` method:
- Basic template structure
- Docstring inclusion
- Function limiting (max 5)
- Pass statement inclusion
- TODO comment presence
- Empty functions handling
- Valid Python syntax validation

**Coverage**: Template correctness, syntactic validity

#### 9. TestGenerateVitestReactTemplate (7 tests)
Tests for the `_generate_vitest_react_template` method:
- Basic React template structure
- React Testing Library import
- UserEvent inclusion
- BeforeEach hook presence
- Test case generation
- Component name usage
- JSDoc comment presence

**Coverage**: React testing patterns, template completeness

#### 10. TestGenerateVitestUtilTemplate (6 tests)
Tests for the `_generate_vitest_util_template` method:
- Basic utility template
- Import TODO comments
- Test block inclusion
- Assertion patterns
- Module name usage
- Valid TypeScript syntax

**Coverage**: Utility function testing patterns

#### 11. TestResultToDict (9 tests)
Tests for the `result_to_dict` helper function:
- Success field preservation
- Auto-generated data handling
- Complex functions conversion to dicts
- Coverage gap conversion
- None coverage gap handling
- Tokens used preservation
- Next steps preservation
- JSON serializability
- Multiple complex functions handling

**Coverage**: Dataclass to dict conversion, serialization

#### 12. TestDataclassSerialization (3 tests)
Tests for dataclass serialization:
- AutoGeneratedTest serialization
- ComplexFunction serialization
- CoverageGap serialization

**Coverage**: All dataclass types used in the module

#### 13. TestTestGeneratorIntegration (3 tests)
Integration tests for complete workflows:
- Full Python analysis to test generation workflow
- Complex workflow with multiple functions
- TypeScript to vitest workflow

**Coverage**: End-to-end scenarios

## Running the Tests

### Run All Tests
```bash
cd /Users/Warmonger0/tac/tac-webbuilder
pytest adws/tests/test_test_generator.py -v
```

### Run Specific Test Class
```bash
pytest adws/tests/test_test_generator.py::TestAnalyzePythonFile -v
```

### Run Single Test
```bash
pytest adws/tests/test_test_generator.py::TestCalculateComplexity::test_nested_control_flow -v
```

### Run with Coverage Report
```bash
pytest adws/tests/test_test_generator.py --cov=adws.adw_modules.test_generator --cov-report=html
```

### Run Only Fast Tests
```bash
pytest adws/tests/test_test_generator.py -v -m "not slow"
```

## Test Organization

### Naming Convention
All test files follow pytest naming conventions:
- Test file: `test_test_generator.py` (starts with `test_`)
- Test classes: `TestClassName` (starts with `Test`)
- Test methods: `test_descriptive_name` (starts with `test_`)

### Test Structure (AAA Pattern)
Each test follows the Arrange-Act-Assert pattern:

```python
def test_something(self):
    """Test description."""
    # Arrange
    input_data = prepare_test_data()

    # Act
    result = function_under_test(input_data)

    # Assert
    assert result == expected_value
```

### Fixtures
Fixtures are defined at the top of the file and organized by category:
- **Path fixtures**: project_root, temp files
- **Source code fixtures**: Simple, complex, async, decorated sources
- **Data fixtures**: Coverage gaps, complex functions
- **Reusable fixtures**: Used across multiple test classes

## Key Features

### 1. Comprehensive Edge Case Coverage
- Empty files
- Files with invalid syntax
- Nonexistent files
- Files with only imports
- Files with decorators
- Async functions
- High complexity functions
- Files with various return types

### 2. Multiple File Type Support
Tests cover:
- Python files (`.py`)
- TypeScript files (`.ts`)
- TypeScript React files (`.tsx`)
- JavaScript files (`.jsx`)
- JSX files (`.jsx`)

### 3. Template Validation
Each template generation test verifies:
- Correct imports are included
- Required patterns are present
- Syntax is valid (parsed by `ast.parse()`)
- Placeholders and TODOs are included
- Component/module names are properly used

### 4. Integration Testing
End-to-end workflows test:
- Analysis → Generation → Serialization pipeline
- Multiple complex functions handling
- Different file type workflows

### 5. Dataclass Serialization
All dataclasses used are tested for:
- Correct conversion to dictionaries
- JSON serializability
- Field preservation

## Coverage Goals

Target: **>80% code coverage**

Areas covered:
- ✓ All public methods
- ✓ All private methods (`_calculate_complexity`, `_get_test_file_path`, etc.)
- ✓ All dataclass handling
- ✓ Error paths (exception handling)
- ✓ Edge cases (empty, invalid, special characters)
- ✓ Different code patterns (async, decorators, complex logic)

## Dependencies

The test suite requires:
- `pytest`: Testing framework
- `pytest-mock` (optional): For mocking (available via conftest)
- Standard library: `ast`, `json`, `pathlib`, `tempfile`, `unittest.mock`

## Fixtures Used

### Built-in Pytest Fixtures
- `tmp_path`: Temporary directory (auto-created/cleaned)

### Custom Fixtures
All custom fixtures are defined in the test file:
- See "Fixture Definitions" section above

### Shared Fixtures from conftest.py
The `adws/tests/conftest.py` provides additional shared fixtures:
- `temp_directory`: Temporary directory with cleanup
- `project_structure`: Realistic project directory structure
- Various test report fixtures
- Mock fixtures for file operations

## Common Test Patterns

### Pattern 1: Testing Analysis with Temporary Files
```python
def test_analyze_functions(test_generator, tmp_path):
    # Create temp file with source
    source_file = tmp_path / "module.py"
    source_file.write_text(source_code)

    # Analyze
    result = test_generator.analyze_python_file(source_file)

    # Assert
    assert len(result) > 0
    assert result[0]["name"] == "expected_function"
```

### Pattern 2: Testing Path Generation
```python
def test_path_generation(test_generator, project_root):
    source_path = project_root / "app" / "server" / "module.py"

    test_path = test_generator._get_test_file_path(source_path)

    assert test_path.name == "test_module.py"
    assert "tests" in str(test_path)
```

### Pattern 3: Testing Template Generation
```python
def test_template(test_generator):
    template = test_generator._generate_pytest_template(
        source_path=Path("/app/module.py"),
        functions=[{"name": "func", "args": []}]
    )

    # Verify syntax
    ast.parse(template)  # Will raise if invalid

    # Verify content
    assert "import pytest" in template
    assert "def test_func" in template
```

### Pattern 4: Testing Dataclass Conversion
```python
def test_serialization():
    result = TestGenResult(...)
    result_dict = result_to_dict(result)

    # Verify it's JSON serializable
    json_str = json.dumps(result_dict)
    assert isinstance(json_str, str)
```

## Notes on Test Implementation

### Why Temporary Files?
Many tests use `tmp_path` fixture to create actual files because:
1. Tests `analyze_python_file` which performs real file I/O
2. Tests `generate_pytest_test` which creates test files
3. Ensures cleanup after tests complete
4. Prevents tests from affecting the actual project

### Why AST Parsing for Validation?
Template tests validate generated code by parsing with `ast.parse()` because:
1. Ensures syntactic correctness
2. Catches template generation bugs early
3. Doesn't require actual test execution
4. Fast validation

### Why Parametrization Not Used Extensively?
While pytest parametrization is powerful, this test suite uses:
- Class-based organization for related tests
- Separate test methods for clarity
- Fixtures for complex setup
This approach is more readable for this use case.

## Future Enhancements

Potential areas for expansion:
1. Performance benchmarking tests
2. Large file handling tests
3. Concurrent analysis tests
4. Coverage report integration tests
5. Template customization tests
6. Multi-language support tests

## Troubleshooting

### Import Errors
If you see import errors like `ModuleNotFoundError: No module named 'adws'`:
1. Ensure you're running from the project root: `/Users/Warmonger0/tac/tac-webbuilder`
2. Check that `conftest.py` is present in `adws/tests/`
3. Try running with: `python -m pytest adws/tests/test_test_generator.py`

### Path-Related Failures
If tests fail with path errors:
1. All paths should be absolute
2. Tests use `tmp_path` for temporary files
3. Mock project root is `/test/project` unless overridden
4. Check Path operations in your test environment

### Fixture Scope Issues
Fixtures are function-scoped by default:
- Created fresh for each test
- Ensures test isolation
- If you need session-scope, modify fixture decorator

## Summary

This comprehensive test suite provides:
- **110+ test cases** covering all major functionality
- **Multiple fixture types** for different test scenarios
- **Edge case handling** for robustness
- **Integration tests** for real-world workflows
- **Clear documentation** and examples
- **>80% code coverage** target

The tests are designed to be maintainable, readable, and serve as documentation for expected behavior.
